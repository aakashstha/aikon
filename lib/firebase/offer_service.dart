import 'package:aikon/controller/auth_controller.dart';
import 'package:aikon/controller/offer_controller.dart';
import 'package:aikon/model/offer_model.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:get/get.dart';

final _offerController = Get.find<OfferController>();
final _authController = Get.find<AuthController>();

// to convert data into particular data type
// data["imagesList"] = List<String>.from(data["imagesList"]);
class FirebaseOfferService {
  static final FirebaseFirestore db = FirebaseFirestore.instance;
  static String offerCollection = "offers";

  // Add Offer
  static Future<void> createOffer() async {
    String randomAutoGeneratedId = db.collection(offerCollection).doc().id;

    var offerData = {
      "id": randomAutoGeneratedId,
      "isSell": _offerController.isSell.value,
      "title": _offerController.titleController.text,
      "subtitle": _offerController.subTitleController.text,
      "description": _offerController.descriptionController.text,
      "country": _offerController.countryController.text,
      "city": _offerController.cityController.text,
      "images": _offerController.selectedImageUrlList,
      "channels": _offerController.channelList,
      "channelsId": _offerController.channelsId,
      "isAnonymous": _offerController.postAnonymously.value,
      "userId": FirebaseAuth.instance.currentUser!.uid,
      "createdAt": DateTime.now(),
    };

    try {
      await db
          .collection(offerCollection)
          .doc(randomAutoGeneratedId)
          .set(offerData);

      print("Offer Added");
    } catch (e) {
      print("Failed to Add Offer:  $e");
    }
  }

  // Get all Offers Details
  static Future<void> getAllMyOffers() async {
    _offerController.myOffersListings.clear();

    try {
      var offerSnapshot = await db
          .collection(offerCollection)
          .where("userId", isEqualTo: FirebaseAuth.instance.currentUser!.uid)
          .orderBy("createdAt")
          .get();

      for (var doc in offerSnapshot.docs) {
        Map<String, dynamic> data = doc.data();
        data["id"] = doc.id;
        // data["imagesList"] = List<String>.from(data["imagesList"]);

        if (FirebaseAuth.instance.currentUser!.uid == data["userId"]) {
          _offerController.myOffersListings.add(OfferModel.fromJson(data));
        }
      }

      print("All My Offers Getting Done");
    } catch (e) {
      print("Failed to Get All My Offers:  $e");
    }
  }

  static Future<void> getAllOtherOffers() async {
    _offerController.otherOffersListings.clear();

    var offerSnapshot;
    print("this is not nice ${_offerController.selectedChannels}");
//  .where("id",whereIn: ["TzKfdZxC2UmZR3LuXWvp", "UaQlp4i23VzPH6nTdrf1"])
    try {
      // if archive list is empty at first
      if (_offerController.selectedChannels.isEmpty &&
          _authController.archiveIdList.isEmpty) {
        offerSnapshot = await db
            .collection(offerCollection)
            .where("isSell",
                isEqualTo: _offerController.toggleStateIsSell.value)
            .orderBy("createdAt")
            .get();
      } else if (_offerController.selectedChannels.isEmpty) {
        // Filter by isSell and archive list  when channel is not selected
        offerSnapshot = await db
            .collection(offerCollection)
            .where("isSell",
                isEqualTo: _offerController.toggleStateIsSell.value)
            .orderBy("createdAt")
            .where("id", whereNotIn: _authController.archiveIdList)
            .get();
      } else {
        // Filter by isSell and selected channels when channel is selected and
        // later remove archive list from the main list
        offerSnapshot = await db
            .collection(offerCollection)
            .where("isSell",
                isEqualTo: _offerController.toggleStateIsSell.value)
            .where("channelsId",
                arrayContainsAny: _offerController.selectedChannelsIdFilter)
            .orderBy("createdAt")
            .get();
      }

      for (var doc in offerSnapshot.docs) {
        Map<String, dynamic> data = doc.data();
        data["id"] = doc.id;

        // First only show other user created offer and
        // later remove archive list from the main list
        if (FirebaseAuth.instance.currentUser!.uid != data["userId"] &&
            !_authController.archiveIdList.contains(doc.id)) {
          _offerController.otherOffersListings.add(OfferModel.fromJson(data));
        }
      }

      print(_offerController.otherOffersListings);
      print("All Other Offers Getting Done");
    } catch (e) {
      print("Failed to Get All Other Offers:  $e");
    }
  }

// Update Offers Details
  static Future<void> updateOffer(String id) async {
    var updateOfferData = {
      "isSell": _offerController.isSell.value,
      "title": _offerController.titleController.text,
      "subtitle": _offerController.subTitleController.text,
      "description": _offerController.descriptionController.text,
      "country": _offerController.countryController.text,
      "city": _offerController.cityController.text,
      "images": _offerController.selectedImageUrlList,
      "channels": _offerController.channelList,
      "isAnonymous": _offerController.postAnonymously.value,
      "userId": FirebaseAuth.instance.currentUser!.uid,
      "createdAt": DateTime.now(),
    };

    try {
      await db.collection(offerCollection).doc(id).update(updateOfferData);
      print("Offer Updated");
    } catch (e) {
      print("Failed to Update Offer:  $e");
    }
  }

  // Delete Offers
  static Future<void> deleteOffer(String id) async {
    try {
      await db.collection(offerCollection).doc(id).delete();

      print("Offer Deleted");
    } catch (e) {
      print("Failed to Delete Offer:  $e");
    }
  }

  // get only favourite offers
  static Future<void> getAllFavouriteOffers() async {
    _offerController.favouriteOfferList.clear();

    try {
      final favouriteRef = db.collection(offerCollection);
      final favourite = await favouriteRef
          .where("id", whereIn: _authController.favouriteIdList)
          .get();

      for (var doc in favourite.docs) {
        Map<String, dynamic> data = doc.data();

        _offerController.favouriteOfferList.add(OfferModel.fromJson(data));
      }

      print("All Favourite Offers Getting Done");
    } catch (e) {
      print("Failed to Get All favourite Offers:  $e");
    }
  }

  // get only archive offers
  static Future<void> getAllArchiveOffers() async {
    _offerController.archiveOfferList.clear();

    try {
      final favouriteRef = db.collection(offerCollection);
      final favourite = await favouriteRef
          .where("id", whereIn: _authController.archiveIdList)
          .get();

      for (var doc in favourite.docs) {
        Map<String, dynamic> data = doc.data();

        _offerController.archiveOfferList.add(OfferModel.fromJson(data));
      }

      print("All Archive Offers Getting Done");
    } catch (e) {
      print("Failed to Get All Archive Offers:  $e");
    }
  }
}
